# Multisensor

![multisensor](/units/multisensor/assets/vindriktning_ikea.jpg "Placeholder")

## Features

| Feature    | Specifications                                                     |
| ---------- | ------------------------------------------------------------------ |
| POE        | 802.3af, 6W                                                        |
| Ethernet   | 802.3-2008, 10/100Mbps                                             |
| WiFi       | 802.11b/g/n, 150Mbps                                               |
| Bluetooth  | Bluetooth v4.2 BR/EDR and Bluetooth LE                             |
| ARGB strip | 5V, WS2812, 15 LEDs                                                |
| SEN54      | PM, NOx, VOC, RH & T                                               |
| LD2450     | 6m range, 140° coverage, tracking up to three simultaneous targets |

## Parts list

| Part                                                       | Datasheet                                                                                       | EU Shop                                                                                                  |
| ---------------------------------------------------------- | ----------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| IKEA Fyrtur                                                | [link](/units/multisensor/docs/vindriktning-air-quality-sensor__AA-2289325-2-100.pdf)           | [link](https://www.ikea.com/us/en/p/vindriktning-air-quality-sensor-60515911/)                           |
| Ceiling mount                                              | [link](/units/multisensor/docs/Delta-Opti%20Datasheet-TP-202.pdf)                               | [link](https://shopdelta.eu/camera-bracket-tp-202_l2_p15561.html)                                        |
| M5Stack POE ESP32                                          | [link](/units/multisensor/docs/poesp32.pdf)                                                     | [link](https://eu.mouser.com/ProductDetail/M5Stack/U138?qs=vvQtp7zwQdPAxf%252BUv9YNIg%3D%3D)             |
| SEN54                                                      | [link](/units/multisensor/docs/Sensirion_Datasheet_Environmental_Node_SEN5x.pdf)                | [link](https://eu.mouser.com/ProductDetail/Sensirion/SEN54-SDN-T?qs=doiCPypUmgETgnCgwG%2FXqw%3D%3D)      |
| JST-GHR-06V Cable (for SEN54)                              | [link](/units/multisensor/docs/DS-18079-Breadboard_to_GHR-06V_Cable_-_6-Pin_x_1.25mm_Pitch.pdf) | [link](https://eu.mouser.com/ProductDetail/SparkFun/CAB-23353?qs=dbcCsuKDzFWqAXy6rd2zQw%3D%3D)           |
| WS2812 320 LEDs/m strip (only 3 segments (15 LEDs) needed) | [link](/units/multisensor/docs/WS2812.pdf)                                                      | [link](https://www.amazon.de/-/en/gp/product/B0CF57NMHN/ref=ox_sc_act_image_1?smid=A3FZWHGYVON1ZP&psc=1) |
| LD2450 radar kit                                           |                                                                                                 |                                                                                                          |

## ESPHome

At the core (pun intended) of the ESP32 runs ESPHome firmware generated by the fallowing configuration:

    # ESPHome
    esphome:
    name: multisensor
    friendly_name: Multisensor
    on_boot:
        - LD2450.zone.update_polygon:
            id: z1
            polygon: !lambda |-
            return {ld2450::Point(id(z1x1).state*1000,id(z1y1).state*1000), ld2450::Point(id(z1x2).state*1000,id(z1y2).state*1000), ld2450::Point(id(z1x3).state*1000,id(z1y3).state*1000), ld2450::Point(id(z1x4).state*1000,id(z1y4).state*1000)};
        - LD2450.zone.update_polygon:
            id: z2
            polygon: !lambda |-
            return {ld2450::Point(id(z2x1).state*1000,id(z2y1).state*1000), ld2450::Point(id(z2x2).state*1000,id(z2y2).state*1000), ld2450::Point(id(z2x3).state*1000,id(z2y3).state*1000), ld2450::Point(id(z2x4).state*1000,id(z2y4).state*1000)};
        - LD2450.zone.update_polygon:
            id: z3
            polygon: !lambda |-
            return {ld2450::Point(id(z3x1).state*1000,id(z3y1).state*1000), ld2450::Point(id(z3x2).state*1000,id(z3y2).state*1000), ld2450::Point(id(z3x3).state*1000,id(z3y3).state*1000), ld2450::Point(id(z3x4).state*1000,id(z3y4).state*1000)};

    esp32:
    board: esp32dev
    variant: ESP32
    framework:
        type: esp-idf

    logger:

    ota:
    - platform: esphome
        password: "aaaaaaaaaaaaaaaaaaaaaaaaaaa"
    # ESPHome

    # Home Assistant
    api:
    encryption:
        key: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    # Home Assistant

    # LED Bar
    e131:
    method: multicast

    light:
    - platform: esp32_rmt_led_strip
        rmt_channel: 0
        rgb_order: GRB
        pin: GPIO4
        num_leds: 15
        chipset: WS2812
        id: led_bar_light
        name: "LED Bar"
        effects:
        - addressable_scan:
            move_interval: 67ms
    # LED Bar

    # Ethernet
    ethernet:
    type: IP101
    mdc_pin: GPIO23
    mdio_pin: GPIO18
    clk_mode: GPIO0_IN
    phy_addr: 1
    power_pin: GPIO5
    manual_ip:
        gateway: 192.168.1.1
        static_ip: 192.168.1.238
        subnet: 255.255.255.0

    text_sensor:
    - platform: ethernet_info
        ip_address:
        name: "IP"
        mac_address:
        name: "MAC"
    # Ethernet

    # Bluetooth
    # esp32_ble_tracker:
    #   scan_parameters:
    #     active: true
    # Bluetooth

    # SEN54
    # i2c:
    #   id: sen5x_i2c
    #   scl: GPIO17
    #   sda: GPIO16

    # sensor:
    # - platform: sen5x
    #   i2c_id: sen5x_i2c
    #   id: sen54
    #   pm_1_0:
    #     name: " PM <1µm Weight concentration"
    #     id: pm_1_0
    #     accuracy_decimals: 1
    #   pm_2_5:
    #     name: " PM <2.5µm Weight concentration"
    #     id: pm_2_5
    #     accuracy_decimals: 1
    #   pm_4_0:
    #     name: " PM <4µm Weight concentration"
    #     id: pm_4_0
    #     accuracy_decimals: 1
    #   pm_10_0:
    #     name: " PM <10µm Weight concentration"
    #     id: pm_10_0
    #     accuracy_decimals: 1
    #   temperature:
    #     name: "Temperature"
    #     accuracy_decimals: 1
    #   humidity:
    #     name: "Humidity"
    #     accuracy_decimals: 0
    #   voc:
    #     name: "VOC"
    #     algorithm_tuning:
    #       index_offset: 100
    #       learning_time_offset_hours: 12
    #       learning_time_gain_hours: 12
    #       gating_max_duration_minutes: 180
    #       std_initial: 50
    #       gain_factor: 230
    #   temperature_compensation:
    #     offset: 0
    #     normalized_offset_slope: 0
    #     time_constant: 0
    #   acceleration_mode: low
    #   store_baseline: true
    #   address: 0x69
    #   update_interval: 10s
    # SEN54

    # mmWave LD2450
    external_components:
    - source: github://TillFleisch/ESPHome-HLK-LD2450@main

    uart:
    id: uart_bus
    tx_pin:
        number: GPIO17
        mode:
        input: true
        pullup: true
    rx_pin:
        number: GPIO16
        mode:
        input: true
        pullup: true
    baud_rate: 256000
    parity: NONE
    stop_bits: 1
    data_bits: 8

    LD2450:
    id: ld2450_radar
    uart_id: uart_bus
    flip_x_axis: true
    fast_off_detection: true
    tracking_mode_switch:
        name: "Multiple Target Tracking"
    occupancy:
        name: "Occupancy"
    target_count:
        name: "Target Count"

    targets:
        - target:
            id: t1
            x_position:
                id: t1_xpos
            y_position:
                id: t1_ypos
        - target:
            id: t2
            x_position:
                id: t2_xpos
            y_position:
                id: t2_ypos
        - target:
            id: t3
            x_position:
                id: t3_xpos
            y_position:
                id: t3_ypos

    zones:
        - zone:
            name: "Zone 1"
            id: z1
            polygon:
            lambda: !lambda |-
                return {};
            update_interval: 1s
            occupancy:
            name: "Occupancy"
        - zone:
            name: "Zone 2"
            id: z2
            polygon:
            lambda: !lambda |-
                return {};
            update_interval: 1s
            occupancy:
            name: "Occupancy"
        - zone:
            name: "Zone 3"
            id: z3
            polygon:
            lambda: !lambda |-
                return {};
            update_interval: 1s
            occupancy:
            name: "Occupancy"

    script:
    - id: z1_update
        then:
        - lambda: !lambda |-
            auto polygon = id(z1).get_polygon();
            if (polygon.size() != 4)
                return;
            template_::TemplateNumber* numbers[8] = {id(z1x1), id(z1y1), id(z1x2), id(z1y2), id(z1x3), id(z1y3), id(z1x4), id(z1y4)};
            for(int i = 0; i < 8; i++){
                auto new_state = i % 2 == 0 ? (polygon[int(i/2)].x/1000.0f) : (polygon[int(i/2)].y/1000.0f);
                if (numbers[i]->state != new_state){
                numbers[i]->publish_state(new_state);
                }
            }
    - id: z2_update
        then:
        - lambda: !lambda |-
            auto polygon = id(z2).get_polygon();
            if (polygon.size() != 4)
                return;
            template_::TemplateNumber* numbers[8] = {id(z2x1), id(z2y1), id(z2x2), id(z2y2), id(z2x3), id(z2y3), id(z2x4), id(z2y4)};
            for(int i = 0; i < 8; i++){
                auto new_state = i % 2 == 0 ? (polygon[int(i/2)].x/1000.0f) : (polygon[int(i/2)].y/1000.0f);
                if (numbers[i]->state != new_state){
                numbers[i]->publish_state(new_state);
                }
            }
    - id: z3_update
        then:
        - lambda: !lambda |-
            auto polygon = id(z3).get_polygon();
            if (polygon.size() != 4)
                return;
            template_::TemplateNumber* numbers[8] = {id(z3x1), id(z3y1), id(z3x2), id(z3y2), id(z3x3), id(z3y3), id(z3x4), id(z3y4)};
            for(int i = 0; i < 8; i++){
                auto new_state = i % 2 == 0 ? (polygon[int(i/2)].x/1000.0f) : (polygon[int(i/2)].y/1000.0f);
                if (numbers[i]->state != new_state){
                numbers[i]->publish_state(new_state);
                }
            }
    # mmWave LD2450

    # mmWave LD2450 Zone 1
    number:
    - platform: template
        id: z1x1
        name: "Z1X1"
        initial_value: -6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z1
            polygon: !lambda |-
                return {ld2450::Point(x*1000,id(z1y1).state*1000), ld2450::Point(id(z1x2).state*1000,id(z1y2).state*1000), ld2450::Point(id(z1x3).state*1000,id(z1y3).state*1000), ld2450::Point(id(z1x4).state*1000,id(z1y4).state*1000)};
        - script.execute: z1_update

    - platform: template
        id: z1y1
        name: "Z1Y1"
        initial_value: 0
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z1
            polygon: !lambda |-
                return {ld2450::Point(id(z1x1).state*1000,x*1000), ld2450::Point(id(z1x2).state*1000,id(z1y2).state*1000), ld2450::Point(id(z1x3).state*1000,id(z1y3).state*1000), ld2450::Point(id(z1x4).state*1000,id(z1y4).state*1000)};
        - script.execute: z1_update

    - platform: template
        id: z1x2
        name: "Z1X2"
        initial_value: -6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z1
            polygon: !lambda |-
                return {ld2450::Point(id(z1x1).state*1000,id(z1y1).state*1000), ld2450::Point(x*1000,id(z1y2).state*1000), ld2450::Point(id(z1x3).state*1000,id(z1y3).state*1000), ld2450::Point(id(z1x4).state*1000,id(z1y4).state*1000)};
        - script.execute: z1_update

    - platform: template
        id: z1y2
        name: "Z1Y2"
        initial_value: 6
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z1
            polygon: !lambda |-
                return {ld2450::Point(id(z1x1).state*1000,id(z1y1).state*1000), ld2450::Point(id(z1x2).state*1000,x*1000), ld2450::Point(id(z1x3).state*1000,id(z1y3).state*1000), ld2450::Point(id(z1x4).state*1000,id(z1y4).state*1000)};
        - script.execute: z1_update

    - platform: template
        id: z1x3
        name: "Z1X3"
        initial_value: 6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z1
            polygon: !lambda |-
                return {ld2450::Point(id(z1x1).state*1000,id(z1y1).state*1000), ld2450::Point(id(z1x2).state*1000,id(z1y2).state*1000), ld2450::Point(x*1000,id(z1y3).state*1000), ld2450::Point(id(z1x4).state*1000,id(z1y4).state*1000)};
        - script.execute: z1_update

    - platform: template
        id: z1y3
        name: "Z1Y3"
        initial_value: 6
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z1
            polygon: !lambda |-
                return {ld2450::Point(id(z1x1).state*1000,id(z1y1).state*1000), ld2450::Point(id(z1x2).state*1000,id(z1y2).state*1000), ld2450::Point(id(z1x3).state*1000,x*1000), ld2450::Point(id(z1x4).state*1000,id(z1y4).state*1000)};
        - script.execute: z1_update

    - platform: template
        id: z1x4
        name: "Z1X4"
        initial_value: 6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z1
            polygon: !lambda |-
                return {ld2450::Point(id(z1x1).state*1000,id(z1y1).state*1000), ld2450::Point(id(z1x2).state*1000,id(z1y2).state*1000), ld2450::Point(id(z1x3).state*1000,id(z1y3).state*1000), ld2450::Point(x*1000,id(z1y4).state*1000)};
        - script.execute: z1_update

    - platform: template
        id: z1y4
        name: "Z1Y4"
        initial_value: 0
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z1
            polygon: !lambda |-
                return {ld2450::Point(id(z1x1).state*1000,id(z1y1).state*1000), ld2450::Point(id(z1x2).state*1000,id(z1y2).state*1000), ld2450::Point(id(z1x3).state*1000,id(z1y3).state*1000), ld2450::Point(id(z1x4).state*1000,x*1000)};
        - script.execute: z1_update
    # mmWave LD2450 Zone 1
    # mmWave LD2450 Zone 2
    - platform: template
        id: z2x1
        name: "Z2X1"
        initial_value: -6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z2
            polygon: !lambda |-
                return {ld2450::Point(x*1000,id(z2y1).state*1000), ld2450::Point(id(z2x2).state*1000,id(z2y2).state*1000), ld2450::Point(id(z2x3).state*1000,id(z2y3).state*1000), ld2450::Point(id(z2x4).state*1000,id(z2y4).state*1000)};
        - script.execute: z2_update

    - platform: template
        id: z2y1
        name: "Z2Y1"
        initial_value: 0
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z2
            polygon: !lambda |-
                return {ld2450::Point(id(z2x1).state*1000,x*1000), ld2450::Point(id(z2x2).state*1000,id(z2y2).state*1000), ld2450::Point(id(z2x3).state*1000,id(z2y3).state*1000), ld2450::Point(id(z2x4).state*1000,id(z2y4).state*1000)};
        - script.execute: z2_update

    - platform: template
        id: z2x2
        name: "Z2X2"
        initial_value: -6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z2
            polygon: !lambda |-
                return {ld2450::Point(id(z2x1).state*1000,id(z2y1).state*1000), ld2450::Point(x*1000,id(z2y2).state*1000), ld2450::Point(id(z2x3).state*1000,id(z2y3).state*1000), ld2450::Point(id(z2x4).state*1000,id(z2y4).state*1000)};
        - script.execute: z2_update

    - platform: template
        id: z2y2
        name: "Z2Y2"
        initial_value: 6
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z2
            polygon: !lambda |-
                return {ld2450::Point(id(z2x1).state*1000,id(z2y1).state*1000), ld2450::Point(id(z2x2).state*1000,x*1000), ld2450::Point(id(z2x3).state*1000,id(z2y3).state*1000), ld2450::Point(id(z2x4).state*1000,id(z2y4).state*1000)};
        - script.execute: z2_update

    - platform: template
        id: z2x3
        name: "Z2X3"
        initial_value: 6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z2
            polygon: !lambda |-
                return {ld2450::Point(id(z2x1).state*1000,id(z2y1).state*1000), ld2450::Point(id(z2x2).state*1000,id(z2y2).state*1000), ld2450::Point(x*1000,id(z2y3).state*1000), ld2450::Point(id(z2x4).state*1000,id(z2y4).state*1000)};
        - script.execute: z2_update

    - platform: template
        id: z2y3
        name: "Z2Y3"
        initial_value: 6
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z2
            polygon: !lambda |-
                return {ld2450::Point(id(z2x1).state*1000,id(z2y1).state*1000), ld2450::Point(id(z2x2).state*1000,id(z2y2).state*1000), ld2450::Point(id(z2x3).state*1000,x*1000), ld2450::Point(id(z2x4).state*1000,id(z2y4).state*1000)};
        - script.execute: z2_update

    - platform: template
        id: z2x4
        name: "Z2X4"
        initial_value: 6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z2
            polygon: !lambda |-
                return {ld2450::Point(id(z2x1).state*1000,id(z2y1).state*1000), ld2450::Point(id(z2x2).state*1000,id(z2y2).state*1000), ld2450::Point(id(z2x3).state*1000,id(z2y3).state*1000), ld2450::Point(x*1000,id(z2y4).state*1000)};
        - script.execute: z2_update

    - platform: template
        id: z2y4
        name: "Z2Y4"
        initial_value: 0
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z2
            polygon: !lambda |-
                return {ld2450::Point(id(z2x1).state*1000,id(z2y1).state*1000), ld2450::Point(id(z2x2).state*1000,id(z2y2).state*1000), ld2450::Point(id(z2x3).state*1000,id(z2y3).state*1000), ld2450::Point(id(z2x4).state*1000,x*1000)};
        - script.execute: z2_update
    # mmWave LD2450 Zone 2
    # mmWave LD2450 Zone 3
    - platform: template
        id: z3x1
        name: "Z3X1"
        initial_value: -6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z3
            polygon: !lambda |-
                return {ld2450::Point(x*1000,id(z3y1).state*1000), ld2450::Point(id(z3x2).state*1000,id(z3y2).state*1000), ld2450::Point(id(z3x3).state*1000,id(z3y3).state*1000), ld2450::Point(id(z3x4).state*1000,id(z3y4).state*1000)};
        - script.execute: z3_update

    - platform: template
        id: z3y1
        name: "Z3Y1"
        initial_value: 0
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z3
            polygon: !lambda |-
                return {ld2450::Point(id(z3x1).state*1000,x*1000), ld2450::Point(id(z3x2).state*1000,id(z3y2).state*1000), ld2450::Point(id(z3x3).state*1000,id(z3y3).state*1000), ld2450::Point(id(z3x4).state*1000,id(z3y4).state*1000)};
        - script.execute: z3_update

    - platform: template
        id: z3x2
        name: "Z3X2"
        initial_value: -6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z3
            polygon: !lambda |-
                return {ld2450::Point(id(z3x1).state*1000,id(z3y1).state*1000), ld2450::Point(x*1000,id(z3y2).state*1000), ld2450::Point(id(z3x3).state*1000,id(z3y3).state*1000), ld2450::Point(id(z3x4).state*1000,id(z3y4).state*1000)};
        - script.execute: z3_update

    - platform: template
        id: z3y2
        name: "Z3Y2"
        initial_value: 6
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z3
            polygon: !lambda |-
                return {ld2450::Point(id(z3x1).state*1000,id(z3y1).state*1000), ld2450::Point(id(z3x2).state*1000,x*1000), ld2450::Point(id(z3x3).state*1000,id(z3y3).state*1000), ld2450::Point(id(z3x4).state*1000,id(z3y4).state*1000)};
        - script.execute: z3_update

    - platform: template
        id: z3x3
        name: "Z3X3"
        initial_value: 6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z3
            polygon: !lambda |-
                return {ld2450::Point(id(z3x1).state*1000,id(z3y1).state*1000), ld2450::Point(id(z3x2).state*1000,id(z3y2).state*1000), ld2450::Point(x*1000,id(z3y3).state*1000), ld2450::Point(id(z3x4).state*1000,id(z3y4).state*1000)};
        - script.execute: z3_update

    - platform: template
        id: z3y3
        name: "Z3Y3"
        initial_value: 6
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z3
            polygon: !lambda |-
                return {ld2450::Point(id(z3x1).state*1000,id(z3y1).state*1000), ld2450::Point(id(z3x2).state*1000,id(z3y2).state*1000), ld2450::Point(id(z3x3).state*1000,x*1000), ld2450::Point(id(z3x4).state*1000,id(z3y4).state*1000)};
        - script.execute: z3_update

    - platform: template
        id: z3x4
        name: "Z3X4"
        initial_value: 6
        min_value: -6
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z3
            polygon: !lambda |-
                return {ld2450::Point(id(z3x1).state*1000,id(z3y1).state*1000), ld2450::Point(id(z3x2).state*1000,id(z3y2).state*1000), ld2450::Point(id(z3x3).state*1000,id(z3y3).state*1000), ld2450::Point(x*1000,id(z3y4).state*1000)};
        - script.execute: z3_update

    - platform: template
        id: z3y4
        name: "Z3Y4"
        initial_value: 0
        min_value: 0
        max_value: 6
        step: 0.1
        restore_value: true
        set_action:
        - LD2450.zone.update_polygon:
            id: z3
            polygon: !lambda |-
                return {ld2450::Point(id(z3x1).state*1000,id(z3y1).state*1000), ld2450::Point(id(z3x2).state*1000,id(z3y2).state*1000), ld2450::Point(id(z3x3).state*1000,id(z3y3).state*1000), ld2450::Point(id(z3x4).state*1000,x*1000)};
        - script.execute: z3_update
    # mmWave LD2450 Zone 3

## Home Assistant

### Cards

#### Radar visualization

![radar_visualization](/units/multisensor/assets/brave_CKwBOIkygG.png)
This radar detection area visualization card example is using [plotly](https://github.com/dbuezas/lovelace-plotly-graph-card) integration in [HACS](https://hacs.xyz/).

    type: custom:plotly-graph
    title: Target Positions
    refresh_interval: 1
    hours_to_show: current_day
    layout:
    height: 230
    margin:
        l: 50
        r: 20
        t: 20
        b: 40
    showlegend: true
    xaxis:
        dtick: 1000
        gridcolor: RGBA(200,200,200,0.15)
        zerolinecolor: RGBA(200,200,200,0.15)
        type: number
        fixedrange: true
        range:
        - 4000
        - -4000
    yaxis:
        dtick: 1000
        gridcolor: RGBA(200,200,200,0.15)
        zerolinecolor: RGBA(200,200,200,0.15)
        scaleanchor: x
        scaleratio: 1
        fixedrange: true
        range:
        - 6000
        - 0
    entities:
    - entity: ''
        name: Target1
        marker:
        size: 12
        line:
        shape: spline
        width: 5
        x:
        - $ex (hass.states["sensor.multisensor_target_1_x_position"].state * 1000)
        'y':
        - $ex (hass.states["sensor.multisensor_target_1_y_position"].state * 1000)
    - entity: ''
        name: Target2
        marker:
        size: 12
        line:
        shape: spline
        width: 5
        x:
        - $ex (hass.states["sensor.multisensor_target_2_x_position"].state * 1000)
        'y':
        - $ex (hass.states["sensor.multisensor_target_2_y_position"].state * 1000)
    - entity: ''
        name: Target3
        marker:
        size: 12
        line:
        shape: spline
        width: 5
        x:
        - $ex (hass.states["sensor.multisensor_target_3_x_position"].state * 1000)
        'y':
        - $ex (hass.states["sensor.multisensor_target_3_y_position"].state * 1000)
    - entity: ''
        name: Coverage
        mode: lines
        fill: tonexty
        fillcolor: rgba(168, 216, 234, 0.15)
        line:
        shape: line
        width: 1
        dash: dot
        x:
        - 0
        - $ex 6000 * Math.sin((2 * Math.PI)/360 * 60)
        - 4500
        - 4000
        - 3000
        - 2000
        - 1000
        - 0
        - -1000
        - -2000
        - -3000
        - -4000
        - -4500
        - $ex -6000 * Math.sin((2 * Math.PI)/360 * 60)
        - 0
        'y':
        - 0
        - $ex 6000 * Math.cos((2 * Math.PI)/360 * 60)
        - $ex Math.sqrt( 6000**2 - 4500**2 )
        - $ex Math.sqrt( 6000**2 - 4000**2 )
        - $ex Math.sqrt( 6000**2 - 3000**2 )
        - $ex Math.sqrt( 6000**2 - 2000**2 )
        - $ex Math.sqrt( 6000**2 - 1000**2 )
        - 6000
        - $ex Math.sqrt( 6000**2 - 1000**2 )
        - $ex Math.sqrt( 6000**2 - 2000**2 )
        - $ex Math.sqrt( 6000**2 - 3000**2 )
        - $ex Math.sqrt( 6000**2 - 4000**2 )
        - $ex Math.sqrt( 6000**2 - 4500**2 )
        - $ex 6000 * Math.cos((2 * Math.PI)/360 * 60)
        - 0
    - entity: ''
        name: Zone 1
        mode: lines
        fill: toself
        fillcolor: RGBA(20,200,0,0.06)
        line:
        color: RGBA(20,200,0,0.2)
        shape: line
        width: 2
        x:
        - $ex (hass.states["number.multisensor_z1x1"].state * 1000)
        - $ex (hass.states["number.multisensor_z1x2"].state * 1000)
        - $ex (hass.states["number.multisensor_z1x3"].state * 1000)
        - $ex (hass.states["number.multisensor_z1x4"].state * 1000)
        - $ex (hass.states["number.multisensor_z1x1"].state * 1000)
        'y':
        - $ex (hass.states["number.multisensor_z1y1"].state * 1000)
        - $ex (hass.states["number.multisensor_z1y2"].state * 1000)
        - $ex (hass.states["number.multisensor_z1y3"].state * 1000)
        - $ex (hass.states["number.multisensor_z1y4"].state * 1000)
        - $ex (hass.states["number.multisensor_z1y1"].state * 1000)
    - entity: ''
        name: Zone 2
        mode: lines
        fill: toself
        fillcolor: RGBA(20,100,200,0.06)
        line:
        color: RGBA(20,100,200,0.2)
        shape: line
        width: 2
        x:
        - $ex (hass.states["number.multisensor_z2x1"].state * 1000)
        - $ex (hass.states["number.multisensor_z2x2"].state * 1000)
        - $ex (hass.states["number.multisensor_z2x3"].state * 1000)
        - $ex (hass.states["number.multisensor_z2x4"].state * 1000)
        - $ex (hass.states["number.multisensor_z2x1"].state * 1000)
        'y':
        - $ex (hass.states["number.multisensor_z2y1"].state * 1000)
        - $ex (hass.states["number.multisensor_z2y2"].state * 1000)
        - $ex (hass.states["number.multisensor_z2y3"].state * 1000)
        - $ex (hass.states["number.multisensor_z2y4"].state * 1000)
        - $ex (hass.states["number.multisensor_z2y1"].state * 1000)
    - entity: ''
        name: Zone 3
        mode: lines
        fill: toself
        fillcolor: RGBA(100,20,200,0.06)
        line:
        color: RGBA(100,20,200,0.2)
        shape: line
        width: 2
        x:
        - $ex (hass.states["number.multisensor_z3x1"].state * 1000)
        - $ex (hass.states["number.multisensor_z3x2"].state * 1000)
        - $ex (hass.states["number.multisensor_z3x3"].state * 1000)
        - $ex (hass.states["number.multisensor_z3x4"].state * 1000)
        - $ex (hass.states["number.multisensor_z3x1"].state * 1000)
        'y':
        - $ex (hass.states["number.multisensor_z3y1"].state * 1000)
        - $ex (hass.states["number.multisensor_z3y2"].state * 1000)
        - $ex (hass.states["number.multisensor_z3y3"].state * 1000)
        - $ex (hass.states["number.multisensor_z3y4"].state * 1000)
        - $ex (hass.states["number.multisensor_z3y1"].state * 1000)
    raw_plotly_config: true

#### Zone configurations

![zone_configuration](/units/multisensor/assets/brave_gwJGACSvdg.png)
When combined with the [radar vizualization](#radar-visualization) these cards help to easily set up the zones in your space. These are examples for three zones, support for more can be added in [Multisensor ESPHome yaml configuration](#esphome).

##### Zone 1

    type: entities
    entities:
    - entity: binary_sensor.multisensor_zone_1_occupancy
    - entity: number.multisensor_z1x1
    - entity: number.multisensor_z1y1
    - entity: number.multisensor_z1x2
    - entity: number.multisensor_z1y2
    - entity: number.multisensor_z1x3
    - entity: number.multisensor_z1y3
    - entity: number.multisensor_z1x4
    - entity: number.multisensor_z1y4
    title: Zone 1

##### Zone 2

    type: entities
    entities:
    - entity: binary_sensor.multisensor_zone_2_occupancy
    - entity: number.multisensor_z2x1
    - entity: number.multisensor_z2y1
    - entity: number.multisensor_z2x2
    - entity: number.multisensor_z2y2
    - entity: number.multisensor_z2x3
    - entity: number.multisensor_z2y3
    - entity: number.multisensor_z2x4
    - entity: number.multisensor_z2y4
    title: Zone 2

##### Zone 3

    type: entities
    entities:
    - entity: binary_sensor.multisensor_zone_3_occupancy
    - entity: number.multisensor_z3x1
    - entity: number.multisensor_z3y1
    - entity: number.multisensor_z3x2
    - entity: number.multisensor_z3y2
    - entity: number.multisensor_z3x3
    - entity: number.multisensor_z3y3
    - entity: number.multisensor_z3x4
    - entity: number.multisensor_z3y4
    title: Zone 3

### Automations
